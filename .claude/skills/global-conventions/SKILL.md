---
name: Global Conventions
description: Follow general development conventions including consistent project structure, environment configuration, dependency management, version control best practices, clear commit messages, and documentation standards. Use this skill when organizing project files and directories, managing dependencies in files like package.json, pnpm-workspace.yaml, requirements.txt, Gemfile, go.mod, Cargo.toml, or composer.json, configuring environment variables in .env, .env.local, .env.production files, writing git commit messages, creating branches, making pull requests, creating or updating README.md files, CONTRIBUTING.md files, CHANGELOG.md files, or other project documentation, setting up configuration files like .gitignore, .editorconfig, .nvmrc, .prettierrc, eslint.config.js, or CI/CD configuration files like .github/workflows/*.yml, or establishing development workflows and team conventions for code reviews, testing, and deployments. Use this when organizing files and directories in a predictable, logical structure that team members can easily navigate following established patterns (like src/ for source code, apps/ for applications in monorepos, packages/ for shared packages, tests/ or __tests__/ for tests, docs/ for documentation, config/ for configuration, scripts/ for build scripts, public/ for static assets), maintaining up-to-date README.md files with clear setup instructions (prerequisites, installation steps, environment setup), architecture overview (tech stack, folder structure, key design decisions), dependency documentation (why major dependencies are used), available scripts (dev, build, test commands), and contribution guidelines for onboarding new team members efficiently, using clear, descriptive commit messages following Conventional Commits format (feat:, fix:, docs:, chore:, refactor:, test:, perf:) or similar standards with meaningful descriptions of what changed and why in the commit body for better git history and automated changelog generation, using feature branches for new development with clear naming conventions (feature/add-user-auth, bugfix/fix-login-error, refactor/simplify-api) and creating meaningful pull requests or merge requests with detailed descriptions of changes, testing performed, breaking changes, and screenshots or videos for UI changes, using environment variables for all configuration values like API endpoints (API_URL), database URLs (DATABASE_URL), API keys (STRIPE_SECRET_KEY), feature flags (ENABLE_NEW_UI), and deployment-specific settings instead of hardcoding them in source code, never committing secrets, API keys, credentials, .env files, or sensitive data to version control and ensuring .gitignore is properly configured to exclude them (add .env, .env.local, .env.*.local, secrets/, *.pem, *.key), keeping dependencies minimal (avoiding adding libraries for trivial functionality), up-to-date (regularly updating to patch security vulnerabilities), and well-documented including explanations in README or comments for why major dependencies are used and their purpose in the project, establishing a consistent code review process with clear expectations for reviewers (check logic, test coverage, security, performance) and authors (self-review first, provide context, respond to feedback) including review checklist items in pull request templates, defining what level of testing is required before merging code (unit tests for business logic, integration tests for API endpoints, end-to-end tests for critical user flows) and enforcing it through CI/CD pipeline checks that must pass before merge, using feature flags or feature toggles (LaunchDarkly, PostHog, or custom implementation) to deploy incomplete features to production safely behind flags rather than maintaining long-lived feature branches that become difficult to merge and cause merge conflicts, keeping a CHANGELOG.md file or release notes to track significant changes, new features, bug fixes, breaking changes, and deprecations for each version following Keep a Changelog format for better communication with users and stakeholders, following semantic versioning (semver) for releases and versioning (MAJOR.MINOR.PATCH: 1.0.0, 1.1.0, 1.1.1) where MAJOR indicates breaking changes, MINOR indicates new features, and PATCH indicates bug fixes, configuring CI/CD pipelines (GitHub Actions, CircleCI, GitLab CI) for automated linting, type checking, testing, building, and deployment triggered on pull requests and merges to main branch, ensuring consistent development environment setup across team members using tools like Docker, devcontainers (.devcontainer/), nvm (.nvmrc), asdf (.tool-versions), or setup scripts (scripts/setup.sh) to minimize "works on my machine" issues, documenting architectural decision records (ADRs) for significant technical decisions explaining context, options considered, and chosen approach, using monorepo tools (pnpm workspaces, Turborepo, Nx) when managing multiple related packages or applications to share code and tooling, and establishing team conventions in CONTRIBUTING.md for branching strategy, commit message format, code review process, release process, and coding standards to ensure consistency across the team.
---

# Global Conventions

## When to use this skill:

- When organizing or restructuring project files and directories for better navigation
- When managing dependencies in package.json, requirements.txt, Gemfile, go.mod, or similar files
- When configuring environment variables and ensuring secrets are not committed to version control
- When writing commit messages that clearly describe changes and their purpose
- When creating or updating README files, setup instructions, or contribution guidelines
- When establishing or following project structure conventions (src/, lib/, config/, etc.)
- When adding or updating major dependencies and documenting why they're used
- When using feature flags to manage incomplete features instead of long-lived branches
- When maintaining changelogs or release notes for tracking significant changes
- When setting up or following code review processes and expectations
- When defining testing requirements before merging code
- When configuring project settings using environment variables rather than hardcoded values
- When ensuring API keys, secrets, and credentials are never committed to repositories
- When organizing files and directories in a predictable, logical structure that team members can navigate easily
- When maintaining up-to-date README files with setup instructions, architecture overview, and contribution guidelines
- When using clear commit messages, feature branches, and meaningful pull/merge requests with descriptions
- When using environment variables for configuration and never committing secrets or API keys to version control
- When keeping dependencies up-to-date and minimal and documenting why major dependencies are used
- When establishing a consistent code review process with clear expectations for reviewers and authors
- When defining what level of testing is required before merging (unit tests, integration tests, etc.)
- When using feature flags for incomplete features rather than long-lived feature branches
- When keeping a changelog or release notes to track significant changes and improvements

This Skill provides Claude Code with specific guidance on how to adhere to coding standards as they relate to how it should handle global conventions.

## Instructions

For details, refer to the information provided in this file:
[global conventions](../../../agent-os/standards/global/conventions.md)
