---
name: Global Error Handling
description: Implement robust error handling with user-friendly messages, fail-fast validation, specific exception types, centralized error boundaries, graceful degradation, retry strategies, and proper resource cleanup. Use this skill when writing try-catch blocks or exception handling code in any programming language (JavaScript/TypeScript, Python, Java, Go, Rust), implementing error boundaries in React (ErrorBoundary components) or similar error handling patterns in other frameworks (Vue error handlers, Angular ErrorHandler), handling API errors and HTTP error responses in fetch calls, Axios requests, or tRPC procedures, validating user input and function preconditions at the start of functions, creating custom error classes or exception types for specific failure scenarios (ValidationError, NotFoundError, UnauthorizedError, PaymentError), implementing retry logic with exponential backoff for external service calls, network requests, or database queries, ensuring proper resource cleanup in finally blocks or using language-specific mechanisms (Python's with, Go's defer, Rust's Drop, try-with-resources in Java), or wrapping async operations in error handling to catch promise rejections and prevent unhandled rejections. Use this when providing clear, actionable error messages to end users that explain what went wrong and what they can do about it (like "Email address is already in use. Please use a different email or reset your password.") without exposing technical implementation details, stack traces, internal error codes, database errors, or security-sensitive information that could aid attackers, validating input parameters and checking preconditions early in functions (at the top, before any processing) and failing fast with clear, specific error messages rather than allowing invalid state to propagate through the system and cause confusing errors later or data corruption, using specific exception or error types like ValidationError for invalid input, NotFoundError for missing resources, UnauthorizedError for auth failures, ForbiddenError for permission issues, DatabaseError for database failures, NetworkError for network issues instead of generic Error or Exception to enable targeted error handling, recovery strategies, and appropriate HTTP status codes in API responses, handling errors at appropriate architectural boundaries like controllers, API route handlers, Next.js API routes, tRPC procedures, or middleware layers rather than scattering try-catch blocks throughout business logic and making error handling difficult to maintain, designing systems to degrade gracefully when non-critical services or features fail (like showing cached data when the API is down, or disabling image uploads when S3 is unavailable) rather than breaking the entire application or showing blank error pages to users, implementing exponential backoff retry strategies for transient failures when calling external APIs, databases, or third-party services (retry after 1s, then 2s, then 4s, then 8s up to a maximum) to handle temporary network issues, rate limiting, or service overload without overwhelming the failing service, always cleaning up resources like file handles, database connections, network sockets, Redis connections, or locks in finally blocks (in languages like JavaScript/Python/Java) or using language-specific mechanisms like Python's with statement for context managers, Go's defer for cleanup, Rust's Drop trait for automatic cleanup, or Java's try-with-resources for AutoCloseable resources to prevent resource leaks even when errors occur, logging errors with appropriate context (user ID, request ID, timestamp, stack trace, relevant parameters) and full error details for debugging and monitoring using tools like console.error, winston, pino, or Sentry while showing sanitized, user-friendly messages to users that don't expose implementation details, creating centralized error handling middleware (Express error middleware, Next.js API error handler) or error boundary components (React ErrorBoundary, Vue errorHandler) to handle errors consistently across the application with standard error formatting, logging, and user messaging instead of repeating error handling code everywhere, throwing errors early when something goes wrong (like throwing ValidationError when input is invalid) rather than returning null, undefined, -1, or other sentinel values and checking for them everywhere which leads to fragile code and missed error cases, implementing circuit breaker patterns for external service dependencies (like opening the circuit after 5 consecutive failures and attempting recovery after 60 seconds) to prevent cascading failures, reduce load on failing services, and provide fast-fail responses instead of timing out on every request, handling promise rejections properly in async/await code with try-catch blocks and ensuring unhandled promise rejections are caught globally with process.on('unhandledRejection') in Node.js to prevent silent failures, using custom error classes that extend Error with additional properties like statusCode, errorCode, details, or context to carry structured error information through the application, distinguishing between operational errors (expected errors like validation failures, not found errors) and program errors (bugs like null reference errors, type errors) and handling them differently (recover from operational errors, crash and restart for program errors), and implementing proper error responses in APIs with appropriate HTTP status codes (400 for validation, 401 for auth, 403 for permissions, 404 for not found, 500 for server errors) and consistent error response format including error message, error code, and field-specific validation errors when applicable.
---

# Global Error Handling

## When to use this skill:

- When implementing try-catch blocks or error handling logic in any language
- When creating custom error classes or exception types for specific failure scenarios
- When handling API errors and returning appropriate HTTP status codes
- When validating user input and checking preconditions early in functions
- When implementing error boundaries in React or similar error handling patterns
- When centralizing error handling at appropriate boundaries (controllers, API layers, middleware)
- When providing user-friendly error messages without exposing technical details or security information
- When implementing retry strategies with exponential backoff for external service calls
- When ensuring graceful degradation when non-critical services fail
- When cleaning up resources (file handles, database connections, network sockets) in finally blocks
- When using specific exception types (ValidationError, NotFoundError) instead of generic Error
- When failing fast with clear error messages rather than allowing invalid state to propagate
- When logging errors with appropriate context for debugging without exposing sensitive data to users
- When providing clear, actionable error messages to users without exposing technical details or security information
- When validating input and checking preconditions early and failing with clear error messages rather than allowing invalid state to continue
- When using specific exception/error types (like ValidationError, NotFoundError, UnauthorizedError) rather than generic Error to enable targeted handling
- When handling errors at appropriate boundaries (controllers, API layers) rather than scattering try-catch blocks everywhere
- When designing systems to degrade gracefully when non-critical services fail rather than breaking entirely
- When implementing exponential backoff for transient failures in external service calls (e.g., retrying with increasing delays)
- When always cleaning up resources (file handles, database connections, network sockets) in finally blocks or equivalent mechanisms

This Skill provides Claude Code with specific guidance on how to adhere to coding standards as they relate to how it should handle global error handling.

## Instructions

For details, refer to the information provided in this file:
[global error handling](../../../agent-os/standards/global/error-handling.md)
