---
name: Global Tech Stack
description: Reference and maintain consistency with the project's technical stack including frameworks, runtimes, languages, frontend libraries, databases, ORMs, testing tools, deployment platforms, and third-party services. Use this skill when making technology choices or selecting libraries that need to align with the existing stack, adding new dependencies to package.json, pnpm-workspace.yaml, requirements.txt, or other dependency management files, implementing features using the project's established frameworks, ORMs, databases, or APIs, writing code in the project's primary language and runtime environment, setting up testing infrastructure with the project's test frameworks, configuring CI/CD pipelines or deployment settings, integrating third-party services that match the project's existing integrations, ensuring compatibility with the project's build tools and bundlers, or ensuring any technical implementation decision aligns with the project's established technologies, architectural patterns, and conventions documented in CLAUDE.md, README.md, or package.json. Use this when referencing and following patterns from the project's application framework like Next.js App Router with Server Components and Server Actions, Rails with ActionCable and Turbo, Django with Django REST Framework, Express.js with middleware patterns, Laravel with Eloquent ORM, Spring Boot with Spring Data JPA, NestJS with dependency injection, or similar framework-specific patterns and conventions, writing code in the project's primary language and runtime environment like TypeScript with strict mode on Node.js 20+, Python 3.11+ with type hints, Ruby 3.x with Sorbet, Java 17+ with records and pattern matching, Go 1.21+ with generics, or Rust with async/await following language idioms and project conventions, using the project's package manager for dependencies like pnpm with workspaces for monorepos, npm with package-lock.json, yarn with Plug'n'Play, pip with requirements.txt or poetry with pyproject.toml, bundler with Gemfile.lock, composer with composer.lock, cargo with Cargo.toml, or go modules with go.mod following the project's established dependency management workflow, implementing frontend features with the project's JavaScript framework like React 19 with hooks and concurrent features, Vue 3 with Composition API, Svelte 4 with stores, SolidJS with fine-grained reactivity, Angular with standalone components, or Qwik with resumability following the framework's best practices and patterns, applying styles using the project's CSS framework or methodology like Tailwind CSS 4 with custom configuration, Bootstrap 5 with Sass customization, CSS Modules with TypeScript, styled-components with theme provider, Emotion with css prop, vanilla-extract with type-safe styles, or Panda CSS with design tokens following the project's styling conventions, building UI components with the project's component library like shadcn/ui with Radix UI primitives, Material UI with custom theme, Ant Design with internationalization, Chakra UI with dark mode, Headless UI with Tailwind, Mantine with hooks, or custom design system with Storybook following component composition patterns and naming conventions, working with the project's database like PostgreSQL 17 with JSONB columns and full-text search, MySQL 8 with spatial data types, MongoDB with aggregation pipelines, SQLite for embedded use cases, or Supabase for backend-as-a-service following database best practices for the chosen technology, querying data using the project's ORM or query builder like Prisma Client with type-safe queries and middleware, Sequelize with migrations and associations, TypeORM with decorators and repositories, Drizzle ORM with SQL-like syntax, ActiveRecord with scopes and callbacks, Mongoose with schemas and validators, SQLAlchemy with declarative models, Knex.js query builder, or raw SQL with parameterized queries following the project's data access patterns and conventions, implementing caching using the project's caching solution like Redis for session storage and job queues with BullMQ, Memcached for distributed caching, in-memory LRU cache for application-level caching, or edge caching with CDN like Cloudflare or Vercel Edge following caching strategies appropriate for the use case, writing tests with the project's test framework like Vitest for unit and integration tests with snapshot support, Jest with React Testing Library for component tests, Playwright for E2E tests with trace viewer, Cypress for E2E tests with time-travel debugging, RSpec for Ruby with FactoryBot fixtures, pytest with fixtures and parametrize, JUnit 5 with Mockito for mocking, or Go testing package with table-driven tests following the project's testing conventions and coverage requirements, following linting and formatting rules using the project's tools like ESLint 9+ with flat config for JavaScript/TypeScript linting, Prettier with opinionated formatting, Biome for fast linting and formatting, RuboCop for Ruby style enforcement, Pylint or Ruff for Python linting, or language-specific tools configured in eslint.config.js, .prettierrc, or similar config files, deploying to the project's hosting platform like Vercel for Next.js apps with edge functions, AWS with ECS/Fargate for containers or Lambda for serverless, Heroku for quick deploys with buildpacks, Railway for full-stack apps, Fly.io for global edge deployment, DigitalOcean App Platform, or VPS with Docker and Traefik for reverse proxy following deployment best practices and infrastructure-as-code when applicable, configuring CI/CD using the project's platform like GitHub Actions with reusable workflows and matrix builds, CircleCI with orbs and parallelism, GitLab CI with stages and artifacts, Jenkins with pipelines, or Bitbucket Pipelines with deployment environments following the project's CI/CD conventions for testing, building, and deploying, implementing authentication with the project's auth solution like NextAuth.js v5 with OAuth providers and Prisma adapter, Auth0 with universal login and RBAC, Clerk with components and webhooks, Supabase Auth with magic links, Firebase Auth with phone verification, Passport.js with strategies, Devise for Rails, or custom JWT implementation following security best practices and the project's auth patterns, sending emails using the project's email service like Resend for transactional emails with React Email templates, SendGrid with dynamic templates and webhooks, Postmark for reliable delivery with bounce tracking, AWS SES for cost-effective bulk sending, Mailgun with email validation API, or custom SMTP configuration following email deliverability best practices, tracking errors and performance using the project's monitoring tools like Sentry for error tracking with source maps and release tracking, PostHog for product analytics with feature flags, LogRocket for session replay with Redux integration, Datadog for infrastructure monitoring and APM, New Relic for application performance monitoring, Axiom or Logflare for structured logging, or custom logging with winston or pino following observability best practices, implementing file storage with the project's solution like AWS S3 for object storage with CloudFront CDN, Cloudflare R2 for S3-compatible storage without egress fees, DigitalOcean Spaces, MinIO for self-hosted S3-compatible storage in development, or Uploadthing for simplified file uploads following secure file handling practices, using the project's API architecture like tRPC for end-to-end type safety with React Query integration, REST with OpenAPI/Swagger documentation, GraphQL with Apollo Server and schema stitching, gRPC for service-to-service communication, or webhooks for event-driven integrations following API design best practices and versioning strategies, and ensuring all new integrations, libraries, and technical decisions are consistent with the established tech stack documented in CLAUDE.md, README.md, package.json dependencies, or architecture decision records to maintain consistency and avoid introducing conflicting technologies or patterns.
---

# Global Tech Stack

## When to use this skill:

- When making technology choices or selecting libraries that need to align with the existing stack
- When implementing features that should follow established framework patterns (Rails, Django, Next.js, Express, etc.)
- When writing code in the project's primary language and runtime (Ruby, Python, Node.js, Java, Go, etc.)
- When adding frontend code that uses the project's JavaScript framework (React, Vue, Svelte, Angular, etc.)
- When applying styles with the project's CSS framework (Tailwind CSS, Bootstrap, CSS Modules, etc.)
- When working with the project's database and ORM (PostgreSQL with Prisma, MySQL with Sequelize, MongoDB with Mongoose, etc.)
- When writing tests using the project's established test framework (Jest, RSpec, pytest, JUnit, etc.)
- When configuring linting, formatting, or code quality tools (ESLint, Prettier, RuboCop, Pylint, etc.)
- When implementing authentication using the project's auth solution (Auth0, Devise, NextAuth, Passport, etc.)
- When integrating with third-party services already used in the project (SendGrid, Sentry, Stripe, etc.)
- When adding dependencies that need to be consistent with the package manager (npm, yarn, pip, bundler, etc.)
- When deploying or configuring infrastructure aligned with hosting platform (AWS, Vercel, Heroku, VPS, etc.)
- When referencing the project's application framework, language/runtime, or package manager to ensure consistency
- When implementing caching using the project's established caching solution (Redis, Memcached, etc.)
- When setting up UI components using the project's component library (shadcn/ui, Material UI, custom library, etc.)
- When configuring CI/CD pipelines aligned with the project's CI/CD platform (GitHub Actions, CircleCI, etc.)
- When implementing email functionality using the project's email service (SendGrid, Postmark, etc.)
- When adding monitoring or error tracking using the project's monitoring tools (Sentry, Datadog, etc.)
- When ensuring all technical implementation decisions align with the project's established tech stack

This Skill provides Claude Code with specific guidance on how to adhere to coding standards as they relate to how it should handle global tech stack.

## Instructions

For details, refer to the information provided in this file:
[global tech stack](../../../agent-os/standards/global/tech-stack.md)
